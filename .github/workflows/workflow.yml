name: Build Web App

on:
  ## This tries to avoid unessesary pushes to forked repo
  ## development branches. No sense in a dev building every
  ## time they push for a PR and no one should be working on
  ## common branches in their fork.
  push:
    branches:
      - master
      - develop
      - 'hotfix/**'
      - 'release/**'
      - 'feature/**'
  pull_request:

jobs:
  test_build_release:

    name: Test, Build, and Publish
    needs: extract_build_info
    env:
      OWNER: ${{ needs.extract_build_info.outputs.repo_owner }}
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v1
      name: Checkout Code

    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.1

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v1

    - name: Restore NuGet Packages
      run: nuget restore legacy-services.sln
      
    - name: Build
      run: |
        REM This will need to change when we add unit tests.
        msbuild LegacyCDE.Web\LegacyCDE.Web.csproj /p:TreatWarningsAsErrors=true /p:Configuration=Release
      shell: cmd

    # TODO: We need some unit tests.
    # - name: Run Unit Tests
    #   run: msbuild test\RunUnitTests.targets /p:Configuration=Release

    - name: Publish
      run: |
        msbuild legacy-services.sln /p:TreatWarningsAsErrors=true /p:Configuration=Release /p:DeployOnBuild=true /p:PublishProfile=FolderProfile
        copy tools\deploy-site.ps1 publish\*.*
      shell: cmd

    - name: Record metadata
      env:
        BUILD_INFO: ${{ toJson( needs.extract_build_info.outputs ) }}
      run: |
        echo "$BUILD_INFO"
        echo "$BUILD_INFO" > $GITHUB_WORKSPACE/publish/dynamic-services/build-info.json
      shell: bash      

    - name: Upload Artifact
      uses: actions/upload-artifact@v1.0.0
      with:
        name: dynamic-services
        path: .\publish

  extract_build_info:
    ## Gather metadata for the build artifact.
    ##
    ## This is done in a separate job so we don't have to figure out how to extract the
    ## same information on every platform.
    ## Ideally, this should be done in a GitHub Action.
    name: Extract build metadata.
    runs-on: ubuntu-latest
    outputs:
      build_name: ${{ steps.set_outputs.outputs.build_name }}
      branch_name: ${{ steps.set_outputs.outputs.branch_name }}
      commit_hash: ${{ steps.set_outputs.outputs.commit_hash }}
      repo_owner: ${{ steps.set_outputs.outputs.repo_owner }}
      repo_name: ${{ steps.set_outputs.outputs.repo_name }}

    steps:
      - name: Set outputs
        id: set_outputs
        run: |
          ## PUSH
          if [ "${{ github.event_name }}" == "push" ]; then
            BUILD_NAME=$(sed -E 's/refs\/(heads|tags)\///; s/\//__/g;' <<< $GITHUB_REF)
            BRANCH_NAME=$(sed -E 's/refs\/(heads|tags)\///;' <<< $GITHUB_REF)
            COMMIT_HASH=$(echo "${GITHUB_SHA}")
          ## PULL_REQUEST
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            BUILD_NAME=$(echo "pr-${{ github.event.pull_request.number }}")
            BRANCH_NAME=$(echo "pr-${{ github.event.pull_request.number }}")
            COMMIT_HASH=$(echo "${{ github.event.pull_request.head.sha }}")
          else
            ## ERROR
            exit 1
          fi
          ## For step checks and artifact deployment path.
          ## Same for push and PR
          export REPO_FULL=${{ github.repository }}
          export REPO_RE='([^/]+)/(.*)'
          [[ "$REPO_FULL" =~ $REPO_RE ]]
          REPO_OWNER=$(echo "${BASH_REMATCH[1]}")
          REPO_NAME=$(echo "${BASH_REMATCH[2]}")
          ## Set step outputs for later use
          echo ::set-output name=build_name::${BUILD_NAME}
          echo ::set-output name=branch_name::${BRANCH_NAME}
          echo ::set-output name=commit_hash::${COMMIT_HASH}
          echo ::set-output name=repo_owner::${REPO_OWNER}
          echo ::set-output name=repo_name::${REPO_NAME}s